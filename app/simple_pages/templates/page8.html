<!doctype html>
<html lang="en">
<head>
    <!-- Required meta tags -->
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <!-- Bootstrap CSS -->
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/css/bootstrap.min.css" rel="stylesheet"
          integrity="sha384-1BmE4kWBq78iYhFldvKuhfTAU6auU8tT94WrHftjDbrCEXSU1oBoqyl2QvZ6jIW3" crossorigin="anonymous">

</head>
<body>
<div class="container">
    <nav class="nav nav-pills nav-fill">
        <a class="nav-link" href="/">Homepage</a>
        <a class="nav-link" href="/page1">Git</a>
        <a class="nav-link" href="/page2">Docker</a>
        <a class="nav-link" href="/page3">Python/Flask</a>
        <a class="nav-link" href="/page4">CI/CD</a>
        <a class="nav-link" href="/page5">Glossary</a>
        <a class="nav-link" href="/page6">AAA Testing</a>
        <a class="nav-link" href="/page7">OOPs</a>
        <a class="nav-link active" aria-current="page" href="/page8">SOLID</a>

    </nav>

    <div class="row">
        <!-- col 1 -->

        <h1 class="font-monospace">SOLID Concepts </h1><br>
        <div class="col-8">
            <h4><b><i>What is SOLID? </i></b></h4><br>
            <p>
                SOLID is an acronym for the first five object-oriented design (OOD) principles by Robert C. Martin (also
                known as Uncle Bob).
            </p>
            <p>
                These principles establish practices that lend to developing software with considerations for
                maintaining and extending as the project grows. Adopting these practices can also contribute to avoiding
                code smells, refactoring code, and Agile or Adaptive software development.
            </p>

            <h4><b><i>S - Single-responsiblity Principle</i></b></h4><br>
            <p>
                Single-responsibility Principle (SRP) states:

                A class should have one and only one reason to change, meaning that a class should have only one job.

            </p>
            <p>
                In our calculator app, in operations file, you can see that we have separate classes
                for each operation, and it only performs one function, which is the actual operation which shows the
                single responsibility principle in the calculator
                app.
            </p>
            <pre class="border-top border-bottom" style="height: 200px"><code>class Subtraction:
    """ This is the subtraction class"""

    @staticmethod
    def subtract(value_1, value_2):
        """ This is the add method"""
        return value_1 - value_2

            </code>

            </pre>
            <h4><b><i>O - Open-closed Principle</i></b></h4><br>
            <p>
                Open-closed Principle (OCP) states:

                Objects or entities should be open for extension but closed for modification.

                This means that a class should be extendable without modifying the class itself.
                In our program we have different functions and classes in our calculations.py and we cannot make any
                modifications in them but we can extend them to us the calculations function.
            </p>
            <pre class="border-top border-bottom" style="height: 200px"><code>class Subtraction:
    """ This is the subtraction class"""

    @staticmethod
    def subtract(value_1, value_2):
        """ This is the add method"""
        return value_1 - value_2

        <h1 class="font-monospace">Object Oriented Programming Principle Concepts </h1><br>
        <div class="col-8">
            <h4><b><i>Encapsulation</i></b></h4><br>
            <p>
                <b><i> Encapsulation </i></b> in Python describes the concept of bundling data and methods within a single unit. So,
                for example, when you create a class, it means you are implementing encapsulation. A class is an example
                of encapsulation as it binds all the data members (instance variables) and methods into a single unit.
            </p>
            <pre><code>class Calculation:
                """ calculation abstract base class"""

                # pylint: disable=too-few-public-methods
                def __init__(self, tuple_list: tuple):
                    """ constructor method"""
                    self.values = Calculation.convert_args_to_tuple_of_float(tuple_list)

                @classmethod
                def create(cls, tuple_list: tuple):
                    """ factory method"""
                    return cls(tuple_list)
            </code></pre>
            <p>
                In this example, we create an Employee class by defining employee attributes such as name and salary as
                an instance variable and implementing behavior using work() and show() instance methods.
            </p>
            <h4><b><i>Inheritance</i></b></h4><br>
            <p>
                <b><i> Inheritance </i></b> in Python describes the concept of bundling data and methods within a single unit. So,
                for example, when you create a class, it means you are implementing encapsulation. A class is an example
                of encapsulation as it binds all the data members (instance variables) and methods into a single unit.
            </p>
            <pre><code>class Calculation:
            """ calculation abstract base class"""

            # pylint: disable=too-few-public-methods
            def __init__(self, tuple_list: tuple):
                """ constructor method"""
                self.values = Calculation.convert_args_to_tuple_of_float(tuple_list)

            @classmethod
            def create(cls, tuple_list: tuple):
                """ factory method"""
                return cls(tuple_list)

            @staticmethod
            def convert_args_to_tuple_of_float(tuple_list):
                """ standardize values to list of floats"""
                list_values_float = []
                for item in tuple_list:
                    list_values_float.append(float(item))
                return tuple(list_values_float)


class Addition(Calculation):
            """ calculation addition class"""

            def get_result(self):
                """get the addition results"""
                sum_of_values = 0.0
                for value in self.values:
                    sum_of_values = Add.add(value, sum_of_values)
                return sum_of_values


            </code>

            </pre>

            <h4><b><i>L - Liskov Substitution Principle</i></b></h4><br>
            <p>
                Liskov Substitution Principle states:

                Let q(x) be a property provable about objects of x of type T. Then q(y) should be provable for objects y
                of type S where S is a subtype of T.

                This means that every subclass or derived class should be substitutable for their base or parent class.

            </p>
            <p>
                This means that, given that class B is a subclass of class A, we should be able to pass an object of
                class B to any method that expects an object of class A and the method should not give any weird output
                in that case.

                This is the expected behavior, because when we use inheritance we assume that the child class inherits
                everything that the superclass has. The child class extends the behavior but never narrows it down.

                Therefore, when a class does not obey this principle, it leads to some nasty bugs that are hard to
                detect.
            </p>

            <h4><b><i>I - Interface Segregation Principle</i></b></h4><br>
            <p>
                Segregation means keeping things separated, and the Interface Segregation Principle is about separating
                the interfaces.

                The principle states that many client-specific interfaces are better than one general-purpose interface.
                Clients should not be forced to implement a function they do no need.
            </p>
            <p>
                Suppose if you enter a restaurant and you are pure vegetarian. The waiter in that restaurant gave you
                the menu card which includes vegetarian items, non-vegetarian items, drinks, and sweets. In this case,
                as a customer, you should have a menu card which includes only vegetarian items, not everything which
                you don’t eat in your food. Here the menu should be different for different types of customers. The
                common or general menu card for everyone can be divided into multiple cards instead of just one. Using
                this principle helps in reducing the side effects and frequency of required changes.
            </p>


            <h4><b><i>D - Dependency Inversion Principle</i></b></h4><br>
            <p>
                Dependency inversion principle states:

                Entities must depend on abstractions, not on concretions. It states that the high-level module must not
                depend on the low-level module, but they should depend on abstractions.

            </p>
            <p>
                if a high module or class will be dependent more on low-level modules or class then your code would have
                tight coupling and if you will try to make a change in one class it can break another class which is
                risky at the production level. So always try to make classes loosely coupled as much as you can and you
                can achieve this through abstraction. The main motive of this principle is decoupling the dependencies
                so if class A changes the class B doesn’t need to care or know about the changes.

            <h4><b><i>Polymorphism</i></b></h4><br>
            <p>
                The word polymorphism means having many forms. In programming, polymorphism means the same function name
                (but different signatures) being used for different types.
            </p>
            <p>
                In Python, Polymorphism lets us define methods in the child class that have the same name as the methods
                in the parent class. In inheritance, the child class inherits the methods from the parent class. However,
                it is possible to modify a method in a child class that it has inherited from the parent class. This is
                particularly useful in cases where the method inherited from the parent class doesn’t quite fit the
                child class. In such cases, we re-implement the method in the child class. This process of re-implementing
                a method in the child class is known as Method Overriding.

            </p>


        </div>
        <!-- col 1 end -->
        <!-- col 2 for images -->

        <div class="col">

            <div class="row mb-3">
                <li><a href="https://github.com/rishimane552">GitHub Repo: Rishikesh Mane</a></li>
            </div>
            <!-- row 1 image1 -->


     
            <!-- row 1 image1 -->
            <div class="row mb-3">
                <img src="{{ url_for('static', filename='images/s1.png') }}" class="img-fluid" alt="Image 1">


        </div>
        <!-- col 2 for images end-->

    </div>
</div>
